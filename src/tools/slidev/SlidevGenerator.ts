/**
 * Slidev 生成器工具
 * 用于生成 Slidev 格式的演示文稿
 */

import { Tool } from '../../Tool.js'

export interface SlidevGeneratorInput {
  title: string
  subtitle?: string
  content: string | string[]
  theme?: string
  config?: {
    aspectRatio?: string
    canvasWidth?: number
    highlighter?: string
    monaco?: boolean
    mdc?: boolean
    drawings?: boolean
    transition?: string
    layout?: string
  }
}

export interface SlidevGeneratorOutput {
  success: boolean
  content?: string
  metadata?: {
    slideCount: number
    estimatedDuration: number
    theme: string
    features: string[]
  }
  error?: string
}

export class SlidevGenerator implements Tool {
  name = 'SlidevGenerator'
  
  description = 'Generate Slidev format presentations from content'

  async execute(input: SlidevGeneratorInput): Promise<SlidevGeneratorOutput> {
    try {
      // 生成 headmatter
      const headmatter = this.generateHeadmatter(input)
      
      // 处理内容
      const slides = Array.isArray(input.content) 
        ? input.content 
        : this.splitContentIntoSlides(input.content)
      
      // 生成封面
      const coverSlide = this.generateCoverSlide(input.title, input.subtitle)
      
      // 组装完整内容
      const slidevContent = [
        headmatter,
        coverSlide,
        ...slides
      ].join('\n\n---\n\n')
      
      return {
        success: true,
        content: slidevContent,
        metadata: {
          slideCount: slides.length + 1,
          estimatedDuration: (slides.length + 1) * 2, // 每页估计 2 分钟
          theme: input.theme || 'default',
          features: this.detectFeatures(slidevContent)
        }
      }
    } catch (_error) {
      return {
        success: false,
        error: `生成失败: ${error instanceof Error ? error.message : String(error)}`
      }
    }
  }

  /**
   * 生成 Slidev headmatter
   */
  private generateHeadmatter(input: SlidevGeneratorInput): string {
    const config = input.config || {}
    
    const headmatter: Record<string, any> = {
      theme: input.theme || 'default',
      title: input.title,
      info: `Generated by WriteFlow Slidev Agent`,
      highlighter: config.highlighter || 'shiki',
      monaco: config.monaco !== false,
      mdc: config.mdc !== false
    }

    if (config.aspectRatio) {
      headmatter.aspectRatio = config.aspectRatio
    }
    
    if (config.canvasWidth) {
      headmatter.canvasWidth = config.canvasWidth
    }

    if (config.transition) {
      headmatter.transition = config.transition
    }

    // 转换为 YAML 格式
    const yamlContent = Object.entries(headmatter)
      .map(([key, value]) => {
        if (typeof value === 'string' && value.includes('\n')) {
          return `${key}: |\n  ${value.replace(/\n/g, '\n  ')}`
        }
        return `${key}: ${value}`
      })
      .join('\n')

    return `---
${yamlContent}
---`
  }

  /**
   * 生成封面幻灯片
   */
  private generateCoverSlide(title: string, subtitle?: string): string {
    const parts = [
      '# ' + title
    ]

    if (subtitle) {
      parts.push('', subtitle)
    }

    parts.push(
      '',
      '<div class="pt-12">',
      '  <span @click="$slidev.nav.next" class="px-2 py-1 rounded cursor-pointer" hover="bg-white bg-opacity-10">',
      '    开始演示 <carbon:arrow-right class="inline"/>',
      '  </span>',
      '</div>'
    )

    return parts.join('\n')
  }

  /**
   * 将内容分割为幻灯片
   */
  private splitContentIntoSlides(content: string): string[] {
    const slides: string[] = []
    const lines = content.split('\n')
    let currentSlide: string[] = []
    let slideContent = 0

    for (const line of lines) {
      // 检测是否应该开始新幻灯片
      if (this.shouldStartNewSlide(line, slideContent)) {
        if (currentSlide.length > 0) {
          slides.push(currentSlide.join('\n'))
          currentSlide = []
          slideContent = 0
        }
      }

      currentSlide.push(line)
      
      // 统计内容量
      if (line.trim()) {
        slideContent++
      }

      // 如果内容过多，分页
      if (slideContent >= 10) {
        slides.push(currentSlide.join('\n'))
        currentSlide = []
        slideContent = 0
      }
    }

    // 添加最后一页
    if (currentSlide.length > 0) {
      slides.push(currentSlide.join('\n'))
    }

    return slides
  }

  /**
   * 判断是否应该开始新幻灯片
   */
  private shouldStartNewSlide(line: string, currentContent: number): boolean {
    // H1 或 H2 标题开始新页
    if (/^#{1,2}\s/.test(line)) {
      return currentContent > 0
    }
    
    // 分隔符
    if (line.trim() === '---') {
      return true
    }

    return false
  }

  /**
   * 检测使用的功能
   */
  private detectFeatures(content: string): string[] {
    const features: string[] = []

    if (content.includes('```')) {
      features.push('code-blocks')
    }

    if (content.includes('<v-click')) {
      features.push('animations')
    }

    if (content.includes('layout:')) {
      features.push('custom-layouts')
    }

    if (content.includes('```mermaid')) {
      features.push('mermaid-diagrams')
    }

    if (content.includes('$$')) {
      features.push('latex-math')
    }

    return features
  }
}

